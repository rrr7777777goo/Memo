상속 : 기존 클래스에 기능 추가 및 재정의하여 새로운 클래스를 정의
! 다중 상속은 Java에서 불가능 !
! private, default 멤버는 자식 클래스에서 접근 불가 (default 멤버의 내부 패키지의 자식 클래스는 접근 가능) !
부모 클래스 - 상속 대상이 되는 기존 클래스
자식 클래스  - 기존 클래스를 상속하는 클래스

상속 형태 예시
1. 부모 클래스 <- 자식 클래스 <- 자식 클래스
2. 자식 클래스 -> 부모 클래스 <- 자식 클래스

super, super()
super <= 부모 클래스와 자식 클래스의 멤버 이름이 같을 때 구분하는 키워드
super() <= 부모 클래스 생성자 호출

오버라이딩 : 부모 클래스의 메소드를 자식 클래스에서 재정의 (오버로딩과 뜻 잘 구분하기)
조건
1. 메소드의 선언부는 부모 클래스의 메소드와 동일
2. 반환 타입에 한해, 부모 클래스의 반환 타입으로 변환할 수 있는 타입으로 변경 가능
3. 부모 클래스의 메소드보다 접근제어자를 더 좁은 범위로 변경 불가
4. 부모 클래스의 메소드보다 더 큰 범위의 예외 선언 불가

다형성(Polymorphism)
- 한 객체가 여러가지 타입을 가질 수 있는 것
- 부모클래스 타입의 참조 변수로 자식클래스 인스턴스 참조

class Person {}
class Student extends Person{}

Person p1 = new Student();
Student s1 = new Person(); <= 이건 안 됨!!!

instanceof : 실제 참조하고 있는 인스턴스의 타입 확인
System.out.println(p1 instanceof Person);

추상 메소드
자식클래스에서 반드시 오버라이딩 해야하는 메소드
선언만하고 구현 내용은 없다
abstract void print();

추상 클래스
하나 이상의 추상 메소드를 포함하는 클래스
반드시 구현해야 하는 부분에 대해 명시적으로 표현
추상 클래스 자체는 객체 생성 불가
abstract class 클래스명 {
   abstract void print();
}

인터페이스
다중 상속처럼 사용할 수 있는 기능
추상메소드와 상수만으로 이루어짐

접근제어자 interface 인터페이스이름 {
 public static final 타입 상수이름 = 값;
 public abstract 반환타입 메소드이름(매개변수);
 ...
}

class 클래스이름 implements 인터페이스이름 {
   ...
}
